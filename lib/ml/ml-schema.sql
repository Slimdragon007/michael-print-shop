-- ML Error Prevention and Learning Schema
-- Add these tables to your existing Supabase database

-- Table for tracking photo processing errors
CREATE TABLE IF NOT EXISTS photo_processing_errors (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    error_type VARCHAR(50) NOT NULL CHECK (error_type IN (
        'file_corruption', 'size_invalid', 'format_unsupported', 
        'metadata_missing', 'processing_failed', 'upload_failed'
    )),
    error_message TEXT NOT NULL,
    file_path TEXT NOT NULL,
    file_size BIGINT,
    file_format VARCHAR(20),
    metadata JSONB,
    processing_step VARCHAR(50) NOT NULL CHECK (processing_step IN (
        'validation', 'resize', 'watermark', 'upload', 'etsy_export'
    )),
    context JSONB,
    resolved BOOLEAN DEFAULT FALSE,
    resolution TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for tracking successful processing
CREATE TABLE IF NOT EXISTS photo_processing_successes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    file_path TEXT NOT NULL,
    file_size BIGINT NOT NULL,
    file_format VARCHAR(20) NOT NULL,
    metadata JSONB,
    processing_time_ms INTEGER NOT NULL,
    output_variants TEXT[] DEFAULT '{}',
    quality_score DECIMAL(3,2),
    etsy_exported BOOLEAN DEFAULT FALSE,
    website_imported BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for ML predictions and validations
CREATE TABLE IF NOT EXISTS photo_processing_predictions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    file_path TEXT NOT NULL,
    prediction JSONB NOT NULL,
    actual_outcome VARCHAR(20), -- 'success', 'failed', 'pending'
    prediction_accuracy DECIMAL(3,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    validated_at TIMESTAMP WITH TIME ZONE
);

-- Table for retry attempts and their outcomes
CREATE TABLE IF NOT EXISTS photo_processing_retries (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    original_error_id UUID REFERENCES photo_processing_errors(id),
    retry_attempt INTEGER NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    successful BOOLEAN NOT NULL,
    new_error_type VARCHAR(50),
    new_error_message TEXT,
    time_between_retries_ms INTEGER,
    strategy_used VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for learned fixes and solutions
CREATE TABLE IF NOT EXISTS photo_processing_fixes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    error_type VARCHAR(50) NOT NULL,
    fix_type VARCHAR(50) NOT NULL,
    fix_description TEXT NOT NULL,
    fix_implementation JSONB,
    success_rate DECIMAL(3,2),
    times_applied INTEGER DEFAULT 0,
    successful_applications INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for pattern insights generated by AI
CREATE TABLE IF NOT EXISTS photo_processing_insights (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    error_type VARCHAR(50) NOT NULL,
    insights TEXT NOT NULL,
    error_count INTEGER NOT NULL,
    confidence_score DECIMAL(3,2),
    implemented BOOLEAN DEFAULT FALSE,
    implementation_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for file quality assessments
CREATE TABLE IF NOT EXISTS photo_quality_assessments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    file_path TEXT NOT NULL,
    quality_score DECIMAL(3,2) NOT NULL,
    assessment_details JSONB,
    assessed_by VARCHAR(50) DEFAULT 'ml_system',
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    human_verified BOOLEAN DEFAULT FALSE,
    human_score DECIMAL(3,2)
);

-- Table for processing performance metrics
CREATE TABLE IF NOT EXISTS processing_performance_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    date DATE NOT NULL,
    total_files_processed INTEGER DEFAULT 0,
    successful_processes INTEGER DEFAULT 0,
    failed_processes INTEGER DEFAULT 0,
    average_processing_time_ms INTEGER,
    total_processing_time_ms BIGINT DEFAULT 0,
    errors_by_type JSONB,
    success_rate DECIMAL(5,2),
    improvement_suggestions TEXT[],
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Table for ML model performance tracking
CREATE TABLE IF NOT EXISTS ml_model_performance (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version VARCHAR(50) NOT NULL,
    evaluation_date DATE NOT NULL,
    accuracy DECIMAL(5,2) NOT NULL,
    precision_score DECIMAL(5,2),
    recall_score DECIMAL(5,2),
    f1_score DECIMAL(5,2),
    false_positives INTEGER DEFAULT 0,
    false_negatives INTEGER DEFAULT 0,
    true_positives INTEGER DEFAULT 0,
    true_negatives INTEGER DEFAULT 0,
    total_predictions INTEGER NOT NULL,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for better performance
CREATE INDEX IF NOT EXISTS idx_processing_errors_type ON photo_processing_errors(error_type);
CREATE INDEX IF NOT EXISTS idx_processing_errors_timestamp ON photo_processing_errors(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_processing_errors_file_path ON photo_processing_errors(file_path);
CREATE INDEX IF NOT EXISTS idx_processing_errors_step ON photo_processing_errors(processing_step);
CREATE INDEX IF NOT EXISTS idx_processing_errors_resolved ON photo_processing_errors(resolved);

CREATE INDEX IF NOT EXISTS idx_processing_successes_timestamp ON photo_processing_successes(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_processing_successes_format ON photo_processing_successes(file_format);
CREATE INDEX IF NOT EXISTS idx_processing_successes_quality ON photo_processing_successes(quality_score DESC);

CREATE INDEX IF NOT EXISTS idx_predictions_timestamp ON photo_processing_predictions(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_predictions_outcome ON photo_processing_predictions(actual_outcome);
CREATE INDEX IF NOT EXISTS idx_predictions_accuracy ON photo_processing_predictions(prediction_accuracy DESC);

CREATE INDEX IF NOT EXISTS idx_retries_error_id ON photo_processing_retries(original_error_id);
CREATE INDEX IF NOT EXISTS idx_retries_successful ON photo_processing_retries(successful);

CREATE INDEX IF NOT EXISTS idx_fixes_error_type ON photo_processing_fixes(error_type);
CREATE INDEX IF NOT EXISTS idx_fixes_success_rate ON photo_processing_fixes(success_rate DESC);

CREATE INDEX IF NOT EXISTS idx_insights_error_type ON photo_processing_insights(error_type);
CREATE INDEX IF NOT EXISTS idx_insights_implemented ON photo_processing_insights(implemented);

CREATE INDEX IF NOT EXISTS idx_quality_score ON photo_quality_assessments(quality_score DESC);
CREATE INDEX IF NOT EXISTS idx_quality_human_verified ON photo_quality_assessments(human_verified);

CREATE INDEX IF NOT EXISTS idx_performance_date ON processing_performance_metrics(date DESC);
CREATE INDEX IF NOT EXISTS idx_performance_success_rate ON processing_performance_metrics(success_rate DESC);

-- Views for common queries and analytics

-- View for error rate by file type
CREATE OR REPLACE VIEW error_rate_by_file_type AS
SELECT 
    file_format,
    COUNT(*) as total_attempts,
    SUM(CASE WHEN error_type IS NULL THEN 0 ELSE 1 END) as error_count,
    ROUND(
        (SUM(CASE WHEN error_type IS NULL THEN 0 ELSE 1 END)::decimal / COUNT(*)) * 100, 
        2
    ) as error_rate_percent
FROM (
    SELECT file_format, error_type FROM photo_processing_errors
    UNION ALL
    SELECT file_format, NULL FROM photo_processing_successes
) combined
GROUP BY file_format
ORDER BY error_rate_percent DESC;

-- View for processing performance trends
CREATE OR REPLACE VIEW processing_trends AS
SELECT 
    DATE_TRUNC('week', timestamp) as week,
    COUNT(*) as total_files,
    COUNT(CASE WHEN error_type IS NOT NULL THEN 1 END) as errors,
    COUNT(CASE WHEN error_type IS NULL THEN 1 END) as successes,
    ROUND(
        (COUNT(CASE WHEN error_type IS NULL THEN 1 END)::decimal / COUNT(*)) * 100, 
        2
    ) as success_rate_percent
FROM (
    SELECT timestamp, error_type FROM photo_processing_errors
    UNION ALL
    SELECT timestamp, NULL FROM photo_processing_successes
) combined
GROUP BY DATE_TRUNC('week', timestamp)
ORDER BY week DESC;

-- View for most effective fixes
CREATE OR REPLACE VIEW most_effective_fixes AS
SELECT 
    error_type,
    fix_type,
    fix_description,
    times_applied,
    successful_applications,
    ROUND((successful_applications::decimal / NULLIF(times_applied, 0)) * 100, 2) as success_rate_percent
FROM photo_processing_fixes
WHERE times_applied > 0
ORDER BY success_rate_percent DESC, times_applied DESC;

-- View for prediction accuracy tracking
CREATE OR REPLACE VIEW prediction_accuracy_summary AS
SELECT 
    DATE_TRUNC('day', timestamp) as day,
    COUNT(*) as total_predictions,
    COUNT(CASE WHEN actual_outcome IS NOT NULL THEN 1 END) as validated_predictions,
    ROUND(AVG(prediction_accuracy), 3) as avg_accuracy,
    ROUND(MIN(prediction_accuracy), 3) as min_accuracy,
    ROUND(MAX(prediction_accuracy), 3) as max_accuracy
FROM photo_processing_predictions
GROUP BY DATE_TRUNC('day', timestamp)
ORDER BY day DESC;

-- Triggers for updating timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE OR REPLACE TRIGGER update_processing_errors_updated_at 
    BEFORE UPDATE ON photo_processing_errors 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE TRIGGER update_processing_fixes_updated_at 
    BEFORE UPDATE ON photo_processing_fixes 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to automatically validate predictions when outcomes are known
CREATE OR REPLACE FUNCTION validate_prediction()
RETURNS TRIGGER AS $$
BEGIN
    -- Update prediction accuracy when actual outcome is set
    IF NEW.actual_outcome IS NOT NULL AND OLD.actual_outcome IS NULL THEN
        NEW.validated_at = NOW();
        
        -- Calculate accuracy based on prediction vs actual outcome
        NEW.prediction_accuracy = CASE 
            WHEN (NEW.prediction->>'shouldProceed')::boolean = (NEW.actual_outcome = 'success') THEN 1.0
            ELSE 0.0
        END;
    END IF;
    
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE OR REPLACE TRIGGER validate_prediction_trigger
    BEFORE UPDATE ON photo_processing_predictions
    FOR EACH ROW EXECUTE FUNCTION validate_prediction();

-- Function to automatically update daily performance metrics
CREATE OR REPLACE FUNCTION update_daily_metrics()
RETURNS TRIGGER AS $$
DECLARE
    current_date DATE := CURRENT_DATE;
    success_count INTEGER;
    error_count INTEGER;
    total_count INTEGER;
    avg_time INTEGER;
BEGIN
    -- Count successes and errors for today
    SELECT COUNT(*) INTO success_count 
    FROM photo_processing_successes 
    WHERE DATE(timestamp) = current_date;
    
    SELECT COUNT(*) INTO error_count 
    FROM photo_processing_errors 
    WHERE DATE(timestamp) = current_date;
    
    total_count := success_count + error_count;
    
    -- Calculate average processing time
    SELECT AVG(processing_time_ms)::INTEGER INTO avg_time
    FROM photo_processing_successes 
    WHERE DATE(timestamp) = current_date;
    
    -- Insert or update daily metrics
    INSERT INTO processing_performance_metrics (
        date, 
        total_files_processed, 
        successful_processes, 
        failed_processes,
        average_processing_time_ms,
        success_rate
    ) VALUES (
        current_date,
        total_count,
        success_count,
        error_count,
        avg_time,
        CASE WHEN total_count > 0 THEN ROUND((success_count::decimal / total_count) * 100, 2) ELSE 0 END
    )
    ON CONFLICT (date) DO UPDATE SET
        total_files_processed = EXCLUDED.total_files_processed,
        successful_processes = EXCLUDED.successful_processes,
        failed_processes = EXCLUDED.failed_processes,
        average_processing_time_ms = EXCLUDED.average_processing_time_ms,
        success_rate = EXCLUDED.success_rate,
        updated_at = NOW();
    
    RETURN NULL;
END;
$$ language 'plpgsql';

-- Triggers to update metrics on new successes/errors
CREATE OR REPLACE TRIGGER update_metrics_on_success
    AFTER INSERT ON photo_processing_successes
    FOR EACH ROW EXECUTE FUNCTION update_daily_metrics();

CREATE OR REPLACE TRIGGER update_metrics_on_error
    AFTER INSERT ON photo_processing_errors
    FOR EACH ROW EXECUTE FUNCTION update_daily_metrics();

-- Create a unique constraint to prevent duplicate daily metrics
ALTER TABLE processing_performance_metrics 
ADD CONSTRAINT unique_daily_metrics UNIQUE (date);

-- Row Level Security (if needed)
ALTER TABLE photo_processing_errors ENABLE ROW LEVEL SECURITY;
ALTER TABLE photo_processing_successes ENABLE ROW LEVEL SECURITY;
ALTER TABLE photo_processing_predictions ENABLE ROW LEVEL SECURITY;
ALTER TABLE photo_processing_retries ENABLE ROW LEVEL SECURITY;
ALTER TABLE photo_processing_fixes ENABLE ROW LEVEL SECURITY;
ALTER TABLE photo_processing_insights ENABLE ROW LEVEL SECURITY;
ALTER TABLE photo_quality_assessments ENABLE ROW LEVEL SECURITY;
ALTER TABLE processing_performance_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE ml_model_performance ENABLE ROW LEVEL SECURITY;

-- Policies for admin access to ML data
CREATE POLICY "Admins can manage processing errors" ON photo_processing_errors
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Admins can manage processing successes" ON photo_processing_successes
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "Admins can view ML data" ON photo_processing_predictions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() AND role = 'admin'
        )
    );

CREATE POLICY "System can insert ML data" ON photo_processing_predictions
    FOR INSERT WITH CHECK (true); -- Allow system inserts

-- Apply similar policies to other tables
CREATE POLICY "Admins can manage retries" ON photo_processing_retries FOR ALL USING (EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role = 'admin'));
CREATE POLICY "Admins can manage fixes" ON photo_processing_fixes FOR ALL USING (EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role = 'admin'));
CREATE POLICY "Admins can view insights" ON photo_processing_insights FOR SELECT USING (EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role = 'admin'));
CREATE POLICY "Admins can manage quality assessments" ON photo_quality_assessments FOR ALL USING (EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role = 'admin'));
CREATE POLICY "Admins can view performance metrics" ON processing_performance_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role = 'admin'));
CREATE POLICY "Admins can manage ML performance" ON ml_model_performance FOR ALL USING (EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role = 'admin'));

-- Insert some initial fix strategies
INSERT INTO photo_processing_fixes (error_type, fix_type, fix_description, fix_implementation) VALUES
('file_corruption', 'skip_file', 'Skip corrupted files and log for manual review', '{"action": "skip", "log_level": "warning"}'),
('size_invalid', 'auto_resize', 'Automatically resize files that are too large', '{"max_size": 50000000, "quality": 85}'),
('format_unsupported', 'convert_format', 'Convert unsupported formats to JPEG', '{"target_format": "jpeg", "quality": 90}'),
('metadata_missing', 'generate_metadata', 'Generate basic metadata from filename and file stats', '{"use_filename": true, "extract_exif": true}'),
('processing_failed', 'retry_with_lower_quality', 'Retry processing with lower quality settings', '{"quality": 75, "max_retries": 2}'),
('upload_failed', 'retry_with_backoff', 'Retry upload with exponential backoff', '{"initial_delay": 1000, "max_delay": 30000, "max_retries": 5}')
ON CONFLICT DO NOTHING;